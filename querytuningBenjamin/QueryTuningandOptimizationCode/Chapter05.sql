
-- Chapter 5

-- if you run the following code to create a primary key, where the CLUSTERED or NONCLUSTERED keywords are not specified
CREATE TABLE table1 (
col1 int NOT NULL,
col2 nchar(10) NULL,
CONSTRAINT PK_table1 PRIMARY KEY(col1)
)

-- or
CREATE TABLE table1
(
col1 int NOT NULL,
col2 nchar(10) NULL
)
GO
ALTER TABLE table1 ADD CONSTRAINT
PK_table1 PRIMARY KEY
(
col1
)

-- the code generated by the Table Designer will explicitly request a clustered index for the primary key
ALTER TABLE table1 ADD CONSTRAINT
PK_table1 PRIMARY KEY CLUSTERED
(
col1
)

-- changing the previous code to create a nonclustered index will look like the following statement
ALTER TABLE table1 ADD CONSTRAINT
PK_table1 PRIMARY KEY NONCLUSTERED
(
col1
)

-- create a new table by running the following statement:
SELECT * INTO dbo.SalesOrderDetail
FROM Sales.SalesOrderDetail

-- let’s use the sys.indexes catalog view to inspect the table properties:
SELECT * FROM sys.indexes
WHERE object_id = OBJECT_ID('dbo.SalesOrderDetail')

-- let’s create a nonclustered index:
CREATE INDEX IX_ProductID ON dbo.SalesOrderDetail(ProductID)

-- now create a clustered index:
CREATE CLUSTERED INDEX IX_SalesOrderID_SalesOrderDetailID
ON dbo.SalesOrderDetail(SalesOrderID, SalesOrderDetailID)

-- dropping the nonclustered index will remove the index pages entirely, leaving only the clustered index:
DROP INDEX dbo.SalesOrderDetail.IX_ProductID

-- but notice that deleting the clustered index, which is considered the entire table
DROP INDEX dbo.SalesOrderDetail.IX_SalesOrderID_SalesOrderDetailID

-- for example, the following query is already covered by an existing index, IX_SalesOrderHeader_CustomerID
SELECT SalesOrderID, CustomerID FROM Sales.SalesOrderHeader
WHERE CustomerID = 16448

-- if we slightly change the query to also request the SalesPersonID column
SELECT SalesOrderID, CustomerID, SalesPersonID FROM Sales.SalesOrderHeader
WHERE CustomerID = 16448

-- at this point, you may decide to just update an existing index to include the required column
CREATE INDEX IX_SalesOrderHeader_CustomerID_SalesPersonID
ON Sales.SalesOrderHeader(CustomerID)
INCLUDE (SalesPersonID)

-- finally, to clean up, drop the temporarily created index:
DROP INDEX Sales.SalesOrderHeader.IX_SalesOrderHeader_CustomerID_SalesPersonID

-- for example, if you look at the plan for the following query
SELECT CustomerID, OrderDate, AccountNumber FROM Sales.SalesOrderHeader
WHERE CustomerID = 13917 AND TerritoryID = 4

-- create the following filtered index:
CREATE INDEX IX_CustomerID ON Sales.SalesOrderHeader(CustomerID)
WHERE TerritoryID = 4

-- using our current example, the following query will show an UnmatchedIndexes warning
DECLARE @territory int
SET @territory = 4
SELECT CustomerID, OrderDate, AccountNumber FROM Sales.SalesOrderHeader
WHERE CustomerID = 13917 AND TerritoryID = @territory

-- drop the index before continuing:
DROP INDEX Sales.SalesOrderHeader.IX_CustomerID

-- as an example, look at the next query, which uses an Index Seek operator and produces the plan in Figure 5-5:
SELECT ProductID, SalesOrderID, SalesOrderDetailID
FROM Sales.SalesOrderDetail
WHERE ProductID = 771

-- compare the following query to the previous example
SELECT ProductID, SalesOrderID, SalesOrderDetailID
FROM Sales.SalesOrderDetail
WHERE ABS(ProductID) = 771

-- finally, take a look at the following query and the Index Seek operator properties in Figure 5-9:
SELECT ProductID, SalesOrderID, SalesOrderDetailID
FROM Sales.SalesOrderDetail
WHERE ProductID = 771 AND ABS(SalesOrderID) = 45233

-- to get started, create a new table on the AdventureWorks database:
SELECT * INTO dbo.SalesOrderDetail
FROM Sales.SalesOrderDetail

-- copy the following query and save it to a file:
SELECT * FROM dbo.SalesOrderDetail
WHERE ProductID = 897

-- run this query to inspect the contents of the msdb..DTA_reports_query table:
SELECT * FROM msdb..DTA_reports_query

-- in our example, it will show the following code:
CREATE CLUSTERED INDEX [_dta_index_SalesOrderDetail_c_5_1440724185__K5]
ON [dbo].[SalesOrderDetail]
(
[ProductID] ASC
)WITH (SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF) ON [PRIMARY]

-- keep in mind that hypothetical indexes cannot be used by your queries and are only useful to the DTA.
CREATE CLUSTERED INDEX cix_ProductID ON dbo.SalesOrderDetail(ProductID)
WITH STATISTICS_ONLY

-- you can validate that a hypothetical index was created by running the next query:
SELECT * FROM sys.indexes
WHERE object_id = OBJECT_ID('dbo.SalesOrderDetail')
AND name = 'cix_ProductID'

-- remove the hypothetical index by running this statement:
DROP INDEX dbo.SalesOrderDetail.cix_ProductID

-- let’s clear the plan cache and run only one query in Management Studio:
DBCC FREEPROCCACHE
GO
SELECT SalesOrderID, OrderQty, ProductID
FROM dbo.SalesOrderDetail
WHERE CarrierTrackingNumber = 'D609-4F2A-9B'

-- after the analysis is completed, you can select the Recommendations tab
CREATE NONCLUSTERED INDEX [_dta_index_SalesOrderDetail_5_807673925__K3_1_4_5]
ON [dbo].[SalesOrderDetail]
(
[CarrierTrackingNumber] ASC
)
INCLUDE ([SalesOrderID],
[OrderQty],
[ProductID]) WITH (SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF)
ON [PRIMARY]

-- finally, drop the table you just created by running the following statement:
DROP TABLE dbo.SalesOrderDetail

-- i am using the following input file (saved as input.xml) for this example
<?xml version="1.0" encoding="utf-16" ?>
<DTAXML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xmlns="http://schemas.microsoft.com/sqlserver/2004/07/dta">
<DTAInput>
	<Server>
		<Name>production_instance</Name>
		<Database>
			<Name>AdventureWorks2012</Name>
		</Database>
	</Server>
	<Workload>
		<File>workload.sql</File>
	</Workload>
	<TuningOptions>
		<TestServer>test_instance</TestServer>
		<FeatureSet>IDX</FeatureSet>
		<Partitioning>NONE</Partitioning>
		<KeepExisting>NONE</KeepExisting>
	</TuningOptions>
</DTAInput>
</DTAXML>

-- create the workload.sql file containing a simple query like this:
SELECT * FROM AdventureWorks2012.Sales.SalesOrderDetail
WHERE ProductID = 898

-- Run the following command
dta -ix input.xml -S production_instance -s session1

-- optionally, you can keep the shell database
<TuningOptions>
	<TestServer>test_instance</TestServer>
	<FeatureSet>IDX</FeatureSet>
	<Partitioning>NONE</Partitioning>
	<KeepExisting>NONE</KeepExisting>
	<RetainShellDB>1</RetainShellDB>
</TuningOptions>

-- running the following query on the regular AdventureWorks2012 database creates the following plan
SELECT * FROM Sales.SalesOrderDetail
WHERE ProductID = 898

-- first, create the Sales schema:
CREATE SCHEMA Sales

-- create the dbo.SalesOrderDetail table on the AdventureWorks2012 database by running the following statement:
SELECT * INTO dbo.SalesOrderDetail
FROM Sales.SalesOrderDetail

-- run this query and request a graphical or XML execution plan:
SELECT * FROM dbo.SalesOrderDetail
WHERE SalesOrderID = 43670 AND SalesOrderDetailID > 112

-- in our case, we’re just going to create a nonrelated index by running the following statement:
CREATE INDEX IX_ProductID ON dbo.SalesOrderDetail(ProductID)

-- create the recommended index, after you provide a name for it, by running the following statement:
CREATE NONCLUSTERED INDEX IX_SalesOrderID_SalesOrderDetailID
ON [dbo].[SalesOrderDetail]([SalesOrderID], [SalesOrderDetailID])

-- finally, remove the dbo.SalesOrderDetail table you’ve just created by running the following statement:
DROP TABLE dbo.SalesOrderDetail

-- the following example will return fragmentation information for the Sales.SalesOrderDetail table
SELECT a.index_id, name, avg_fragmentation_in_percent, fragment_count,
avg_fragment_size_in_pages
FROM sys.dm_db_index_physical_stats (DB_ID('AdventureWorks2012'),
OBJECT_ID('Sales.SalesOrderDetail'), NULL, NULL, NULL) AS a
JOIN sys.indexes AS b ON a.object_id = b.object_id AND a.index_id = b.index_id

-- to rebuild all the indexes on the SalesOrderDetail table, use the following statement:
ALTER INDEX ALL ON Sales.SalesOrderDetail REBUILD

-- in case you need to reorganize the index, which is not the case here, you can use a command like this:
ALTER INDEX ALL ON Sales.SalesOrderDetail REORGANIZE

-- as an example, run the following code to create a new table with a nonclustered index:
SELECT * INTO dbo.SalesOrderDetail
FROM Sales.SalesOrderDetail
CREATE NONCLUSTERED INDEX IX_ProductID ON dbo.SalesOrderDetail(ProductID)

-- when you run the following query, it will initially contain only one record
SELECT DB_NAME(database_id) AS database_name,
OBJECT_NAME(s.object_id) AS object_name, i.name, s.*
FROM sys.dm_db_index_usage_stats s JOIN sys.indexes i
ON s.object_id = i.object_id AND s.index_id = i.index_id
AND OBJECT_ID('dbo.SalesOrderDetail') = s.object_id

-- now run the following query, let’s say, three times:
SELECT * FROM dbo.SalesOrderDetail

-- run the next query, which uses an Index Seek, twice
SELECT ProductID FROM dbo.SalesOrderDetail
WHERE ProductID = 773

-- now, run the following query four times
SELECT * FROM dbo.SalesOrderDetail
WHERE ProductID = 773

-- finally, run the following query once:
UPDATE dbo.SalesOrderDetail
SET ProductID = 666
WHERE ProductID = 927

-- finally, drop the table you just created:
DROP TABLE dbo.SalesOrderDetail

